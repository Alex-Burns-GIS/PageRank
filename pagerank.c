// Implementation of PageRank Calculation - Part 1 Assignment 
// COMP2521 - 05/02/2023 
// Author: Alexander Burns - z5118440
//
// Program overview: pagerank.c 
// This program uses an adjacency matrix graph structure to compute the 
// PageRank of mock web pages listed in a file named "collection.txt". The 
// results generated by this program are output to the file "pagerankList.txt".
//
// PageRank is a popular algorithm utilized by Google Search that quantifies 
// the importance of a webpage (and by extension, the pages that link to it) 
// based on the number and quality of incoming links. 

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX_URL_LENGTH 100

struct urlVertex {
    char url[MAX_URL_LENGTH];
    int outDegree;
    double pageRank;
};

bool checkUrl(char* url);
bool duplicateLink(char** links, int numLinks, char* linkArray);
int compare(const void* a, const void* b);
void weightedPageRank(int numUrls, struct urlVertex vertices[], int** adjMatrix, 
                      double d, double diffPR, int maxIterations);


int main(int argc, char **argv) {

    double d = atof(argv[1]);               // Damping factor
    double diffPR = atof(argv[2]);          // Sum of PageRank differences
    int maxIterations = atoi(argv[3]);      // Maximum number of iterations

    FILE* collectionFile = fopen("collection.txt", "r");
    if (collectionFile == NULL) {
        fprintf(stderr, "Error opening collection.txt\n");
        return 1;
    }

    char urlArray[MAX_URL_LENGTH];        
    struct urlVertex *vertices = NULL;
    int numUrls = 0;
    int capacity = 0;

    // Read collection.txt and store whitespace separated URLs in dynamically 
    // allocated array. When fscanf returns 0, meaning it has reached the end 
    // of the file, exit while loop.
    while (fscanf(collectionFile, "%s", urlArray) == 1) {
        if (checkUrl(urlArray) == false) {
            continue;
        }
        if (numUrls >= capacity) {
            capacity = capacity * 2 + 1;
            vertices = realloc(vertices, capacity * sizeof(struct urlVertex));
            if (vertices == NULL) {
                fprintf(stderr, "Error allocating memory\n");
                return 1;
            }
        }
        strcpy(vertices[numUrls].url, urlArray);
        numUrls++;
    }
    fclose(collectionFile);

    // Initialize outDegree values to zero to facilitate later reassignment
    for (int i = 0; i < numUrls; i++) {
        vertices[i].outDegree = 0;
    }

    // Allocate memory for adjacency matrix
    int** adjMatrix = malloc(numUrls * sizeof(int*));
    if (adjMatrix == NULL) {
        fprintf(stderr, "Error allocating memory\n");
        return 1;
    }
    
    for (int i = 0; i < numUrls; i++) {
        adjMatrix[i] = malloc(numUrls * sizeof(int));
        if (adjMatrix[i] == NULL) {
            fprintf(stderr, "Error allocating memory\n");
            return 1;
        }
        for (int j = 0; j < numUrls; j++) {
            adjMatrix[i][j] = 0;
        }
    }

    // For each URL extracted from collection.txt, append ".txt" and open 
    // corresponding file to begin building graph structure
    for (int i = 0; i < numUrls; i++) {
        char filename[MAX_URL_LENGTH + 4];
        sprintf(filename, "%s.txt", vertices[i].url);
        FILE* urlFile = fopen(filename, "r");
        if (urlFile == NULL) {
            printf("Error opening %s\n", filename);
            return 1;
        }
    
        // Read and store unique links from URL file, ignoring self-links 
        // and calling function to treat duplicates links as a single link. 
        int numLinks = 0;
        char linkArray[MAX_URL_LENGTH];
        char** links = NULL;
        while (fscanf(urlFile, "%s", linkArray) == 1) {
            if (strcmp(linkArray, "#end") == 0) {
                break;
            }
            if (strcmp(linkArray, "#start") == 0) {
                continue;
            }
            if (strcmp(linkArray, "Section-1") == 0) {
                continue;
            }
            if (strcmp(linkArray, vertices[i].url) == 0) { 
                continue;
            }
            if (duplicateLink(links, numLinks, linkArray) == true) {
                continue;
            } 
            links = realloc(links, sizeof(char*) * (numLinks + 1));
            links[numLinks] = malloc(sizeof(char) * (strlen(linkArray) + 1));
            strcpy(links[numLinks], linkArray);
            numLinks++;
        }

        // Nested loop iterates over vertices and edges to implement the 
        // adjacency matrix graph structure. When a direct path between 
        // vertices is found, update the relevant out-degree. 
        for (int j = 0; j < numLinks; j++) {
            for (int k = 0; k < numUrls; k++) {
                if (strcmp(links[j], vertices[k].url) == 0) {
                    adjMatrix[i][k] = 1;
                    vertices[i].outDegree++;
                    break;
                }
            }
        } 
    
    // Free allocated memory
    for (int j = 0; j < numLinks; j++) {
        free(links[j]);
    }
    free(links);
    fclose(urlFile);
    }

    // Call function to calculate weighted PageRank values
    weightedPageRank(numUrls, vertices, adjMatrix, d, diffPR, maxIterations);

    // Use standard library function 'qsort' to sort vertices in descending 
    // order of PageRank:
    qsort(vertices, numUrls, sizeof(struct urlVertex), compare);

    // Write the result to pagerankList.txt
    FILE* pageranklist = fopen("pagerankList.txt", "w");
    if (pageranklist == NULL) {
        fprintf(stderr, "Error opening pagerankList.txt\n");
        exit(1);
    }

    for (int i = 0; i < numUrls; i++) {
        fprintf(pageranklist, "%s, %d, %.7lf\n", vertices[i].url, 
                vertices[i].outDegree, vertices[i].pageRank);
    }

    fclose(pageranklist);

    // Free allocated memory
    for (int i = 0; i < numUrls; i++) {
        free(adjMatrix[i]);
    }
    free(adjMatrix);
    free(vertices);

return 0;
    
}

// Function description: Function checks if given URL contains 
// only alphanumeric characters is and <= 100 characters long
bool checkUrl(char* url) {
    int length = strlen(url);
    if (length > MAX_URL_LENGTH) {
        return false;
    }
    for (int i = 0; i < length; i++) {
        if (!isalnum(url[i])) {
            return false;
        }
    }
    return true;
}

// Function description: Function checks if a given link already exists in an 
// array of links. Returns 'true' if the link is found in the array and 
// 'false' otherwise."
bool duplicateLink(char** links, int numLinks, char* linkArray) {
    for (int i = 0; i < numLinks; i++) {
        if (strcmp(links[i], linkArray) == 0) {
            return true;
        }
    }
    return false;
}

// Function description: Function to calculate the weighted PageRank for each
// URL in a graph. It uses the adjacency matrix and out-degree of each vertex 
// to update the PageRank value iteratively. 
void weightedPageRank(int numUrls, struct urlVertex vertices[], int** adjMatrix, 
                      double d, double diffPR, int maxIterations) 
{
    int iteration = 0;
    double sum, diff = diffPR + 1;
    double newPageRanks[numUrls];
    double oldPageRanks[numUrls];

    for (int i = 0; i < numUrls; i++) {
        vertices[i].pageRank = 1.0 / numUrls;
        oldPageRanks[i] = vertices[i].pageRank;
    }

    while (iteration < maxIterations && diff >= diffPR) {
        for (int i = 0; i < numUrls; i++) {
            sum = 0;
            for (int j = 0; j < numUrls; j++) {
                if (adjMatrix[j][i] == 1) {
                    sum += oldPageRanks[j] / vertices[j].outDegree;
                }
            }
            newPageRanks[i] = (1 - d) / numUrls + d * sum;
        }

        diff = 0;
        for (int i = 0; i < numUrls; i++) {
            diff += fabs(newPageRanks[i] - oldPageRanks[i]);
            oldPageRanks[i] = vertices[i].pageRank;
            vertices[i].pageRank = newPageRanks[i];
        }
        iteration++;
    }   
}

// Function description: Function to compare two vertices based on their 
// PageRank values for sorting purposes. The structure of this function was
// taken from: https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/
int compare(const void* a, const void* b) {
    struct urlVertex *v1 = (struct urlVertex *) a;
    struct urlVertex *v2 = (struct urlVertex *) b;
    
    if (v1->pageRank > v2->pageRank) {
        return -1;
    }
    else if (v1->pageRank < v2->pageRank) {
        return 1;
    }
    
    return 0;
}
